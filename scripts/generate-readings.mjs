import fs from "node:fs/promises";
import path from "node:path";
import { glob } from "glob";

const READINGS_DIR = path.resolve("content/readings");
const CONTENT_DIR = path.resolve("content");

// Type display names mapping
const TYPE_DISPLAY_NAMES = {
  "novel": "Novels",
  "nonfiction": "Nonfiction",
  "article": "Articles",
  "short-story": "Short Stories"
};

// Order in which types should appear
const TYPE_ORDER = ["novel", "nonfiction", "article", "short-story"];

// Parse front matter from markdown
function parseFrontMatter(markdown) {
  const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = markdown.match(frontMatterRegex);
  
  if (!match) {
    return { metadata: {}, content: markdown };
  }
  
  const frontMatter = match[1];
  const metadata = {};
  
  frontMatter.split('\n').forEach(line => {
    const colonIndex = line.indexOf(':');
    if (colonIndex > 0) {
      const key = line.substring(0, colonIndex).trim();
      const value = line.substring(colonIndex + 1).trim();
      // Remove quotes if present
      metadata[key] = value.replace(/^["']|["']$/g, '');
    }
  });
  
  return { metadata };
}

async function generateReadingPages() {
  console.log("Generating reading pages...");
  
  // Find all reading files
  const readingFiles = await glob("*.md", { cwd: READINGS_DIR });
  
  if (readingFiles.length === 0) {
    console.log("No reading files found.");
    return;
  }
  
  console.log(`Found ${readingFiles.length} reading file(s).`);
  
  // Read and parse all reading files
  const readings = [];
  
  for (const filename of readingFiles) {
    const filepath = path.join(READINGS_DIR, filename);
    const content = await fs.readFile(filepath, "utf8");
    const { metadata } = parseFrontMatter(content);
    
    if (!metadata.title || !metadata.author || !metadata.date) {
      console.warn(`Skipping ${filename}: missing required front matter (title, author, or date)`);
      continue;
    }
    
    readings.push({
      filename: filename.replace('.md', ''),
      title: metadata.title,
      author: metadata.author,
      date: metadata.date,
      blurb: metadata.blurb || "",
      type: metadata.type || "book" // Default to "book" if no type specified
    });
  }
  
  // Sort by date (most recent first)
  readings.sort((a, b) => new Date(b.date) - new Date(a.date));
  
  console.log("Readings sorted by date (most recent first):");
  readings.forEach(r => console.log(`  - ${r.date}: ${r.title} (${r.type})`));
  
  // Generate home-reading.md content (3 most recent)
  const homeReadings = readings.slice(0, 3);
  const homeContent = generateHomeReadingContent(homeReadings);
  
  // Generate reading.md content (grouped by type)
  const readingContent = generateReadingContent(readings);
  
  // Write files
  await fs.writeFile(path.join(CONTENT_DIR, "home-reading.md"), homeContent, "utf8");
  console.log("✓ Generated content/home-reading.md");
  
  await fs.writeFile(path.join(CONTENT_DIR, "reading.md"), readingContent, "utf8");
  console.log("✓ Generated content/reading.md");
  
  console.log("\n✓ Reading page generation complete!");
}

function generateHomeReadingContent(readings) {
  let content = `---
layout: default
title: Reading
---
## Reading
<!-- NOTE: This file is auto-generated by scripts/generate-readings.mjs -->
<!-- Do not edit manually. Add new readings to content/readings/ and run: npm run generate:readings -->

Follow along with me on the texts that shape my thinking.

**Recent Reads:**

`;
  
  for (const reading of readings) {
    content += `\\- [${reading.title}](/readings/${reading.filename})
    __by ${reading.author}__  
@import(readings.${reading.filename}#blurb)

`;
  }
  
  content += `[See full reading list &rarr;](/reading)`;
  
  return content;
}

function generateReadingContent(readings) {
  let content = `---
layout: default
title: Reading List
---

<!-- NOTE: This file is auto-generated by scripts/generate-readings.mjs -->
<!-- Do not edit manually. Add new readings to content/readings/ and run: npm run generate:readings -->

## Reading List

A very much abridged list of things I have read, occasionally with some of my thoughts.

`;
  
  // Group readings by type
  const readingsByType = {};
  
  for (const reading of readings) {
    if (!readingsByType[reading.type]) {
      readingsByType[reading.type] = [];
    }
    readingsByType[reading.type].push(reading);
  }
  
  // Generate sections for each type in order
  for (const type of TYPE_ORDER) {
    if (readingsByType[type] && readingsByType[type].length > 0) {
      const displayName = TYPE_DISPLAY_NAMES[type] || type.charAt(0).toUpperCase() + type.slice(1);
      content += `### ${displayName}

`;
      
      for (const reading of readingsByType[type]) {
        content += `\\- [${reading.title}](/readings/${reading.filename}) __by ${reading.author}__  
@import(readings.${reading.filename}#blurb)

`;
      }
    }
  }
  
  // Handle any unknown types
  const knownTypes = new Set(TYPE_ORDER);
  for (const type in readingsByType) {
    if (!knownTypes.has(type)) {
      const displayName = TYPE_DISPLAY_NAMES[type] || type.charAt(0).toUpperCase() + type.slice(1);
      content += `### ${displayName}

`;
      
      for (const reading of readingsByType[type]) {
        content += `\\- [__${reading.title}__](/readings/${reading.filename}) by ${reading.author}  
@import(readings.${reading.filename}#blurb)

`;
      }
    }
  }
  content += "\n";
  return content;
}

// Run the generator
generateReadingPages().catch(err => {
  console.error("Error generating reading pages:", err);
  process.exit(1);
});
